// Code generated by Icestudio 0.8.0

`default_nettype none

//---- Top entity
module main (
 input [9:0] ve7d8e2,
 input va4694b,
 input vfc6bff,
 input v8600c1,
 input vec634a,
 input v000e12,
 input v48637e,
 input v1970e5,
 output v9c2cc3,
 output v67965f,
 output v7ce40f,
 output v6911d0,
 output [2:0] v221d02,
 output v8cd66f,
 output vc75e0a,
 output v9e58d5,
 output v366076,
 output vf336c0,
 output ve07ad9,
 output v93bf5a
);
 wire [0:12] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire [0:12] w4;
 wire [0:15] w5;
 wire w6;
 wire [0:7] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:9] w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:2] w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire [0:15] w35;
 assign w9 = vec634a;
 assign w10 = v48637e;
 assign w11 = v1970e5;
 assign v8cd66f = w12;
 assign w13 = vfc6bff;
 assign w14 = v8600c1;
 assign w15 = v000e12;
 assign w16 = ve7d8e2;
 assign v9c2cc3 = w17;
 assign v7ce40f = w18;
 assign vc75e0a = w19;
 assign v9e58d5 = w20;
 assign v221d02 = w21;
 assign v6911d0 = w22;
 assign v67965f = w23;
 assign ve07ad9 = w24;
 assign vf336c0 = w25;
 assign v366076 = w26;
 assign v93bf5a = w27;
 assign w28 = va4694b;
 assign w29 = vfc6bff;
 assign w30 = vfc6bff;
 assign w31 = vfc6bff;
 assign w32 = va4694b;
 assign w33 = va4694b;
 assign w34 = va4694b;
 assign w24 = w8;
 assign w29 = w13;
 assign w30 = w13;
 assign w30 = w29;
 assign w31 = w13;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w28;
 assign w33 = w28;
 assign w33 = w32;
 assign w34 = w28;
 assign w34 = w32;
 assign w34 = w33;
 ve9f529 va8681e (
  .v959b04(w0),
  .v11b8b2(w3),
  .v775544(w4),
  .v0ca728(w8),
  .v3df3e1(w14),
  .v36b650(w15),
  .vdf932c(w16),
  .veaa70d(w20),
  .v82db97(w21),
  .v1eb576(w22),
  .v879a5c(w23),
  .v7803dd(w31),
  .v92a92f(w32),
  .vaabc63(w35)
 );
 v447f87 veb317a (
  .vad664c(w1),
  .vcdfbb7(w2),
  .v76765e(w7),
  .va527ad(w9),
  .v22f8d1(w10),
  .vd2f057(w11),
  .v195b8b(w12),
  .vc8d753(w13)
 );
 v9af2a4 vf42952 (
  .v2cdc1e(w5),
  .v625d28(w6),
  .v54a3a4(w17),
  .ve4659c(w18),
  .v390ac4(w19),
  .v009d3d(w28),
  .v01a7fd(w29)
 );
 v014e82 vc7aca6 (
  .v5a60f2(w0),
  .v05493a(w25),
  .v1955dc(w26),
  .v24805d(w27),
  .v92a92f(w34)
 );
 vfa63e7 vc42eeb (
  .vcd2f9e(w1),
  .va44b93(w2),
  .vd5908e(w3),
  .v4ca04a(w4),
  .v679ba5(w5),
  .vb208b1(w6),
  .vb674e4(w7),
  .vd13f63(w8),
  .vc8d753(w30),
  .v92a92f(w33),
  .v77f475(w35)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module ve9f529 (
 input v7803dd,
 input v92a92f,
 input [9:0] vdf932c,
 input v3df3e1,
 input v36b650,
 input v11b8b2,
 input [12:0] v775544,
 input v0ca728,
 output v879a5c,
 output v1eb576,
 output [2:0] v82db97,
 output veaa70d,
 output [15:0] vaabc63,
 output [12:0] v959b04
);
 wire w0;
 wire [0:9] w1;
 wire w2;
 wire w3;
 wire [0:2] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:12] w11;
 wire [0:15] w12;
 wire [0:12] w13;
 assign w0 = v92a92f;
 assign w1 = vdf932c;
 assign w2 = v3df3e1;
 assign w3 = v36b650;
 assign v82db97 = w4;
 assign v879a5c = w5;
 assign v1eb576 = w6;
 assign veaa70d = w7;
 assign w8 = v0ca728;
 assign w9 = v7803dd;
 assign w10 = v11b8b2;
 assign w11 = v775544;
 assign vaabc63 = w12;
 assign v959b04 = w13;
 ve9f529_vf8ce5e vf8ce5e (
  .DCLK(w0),
  .ADC_DATA(w1),
  .TOP_T1(w2),
  .TOP_T2(w3),
  .RGB(w4),
  .HV_EN(w5),
  .ADC_CLK(w6),
  .EA_CLK(w7),
  .HILO(w8),
  .RST(w9),
  .adc_trig(w10),
  .adc_rd_addr(w11),
  .adc_rd_data(w12),
  .adc_wr_addr(w13)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module ve9f529_vf8ce5e (
 input RST,
 input DCLK,
 input [9:0] ADC_DATA,
 input TOP_T1,
 input TOP_T2,
 input adc_trig,
 input [12:0] adc_rd_addr,
 input HILO,
 output HV_EN,
 output ADC_CLK,
 output [2:0] RGB,
 output EA_CLK,
 output [15:0] adc_rd_data,
 output [12:0] adc_wr_addr
);
  reg         adc_wr_en;
  wire [15:0] adc_wr_data;
  reg  [12:0] adc_wr_addr;
  
  defparam OSCInst0.CLKHF_DIV = "0b00";  //48MHz internal Clock
  SB_HFOSC OSCInst0 ( .CLKHFEN(1'b1), .CLKHFPU(1'b1),.CLKHF(ADC_CLK) 
  ) /* synthesis ROUTE_THROUGH_FABRIC= [0] */;
  
  //@64MHz 8192 Clocks = 128us //@48MHz 8192 Clocks = 170.667us
  always@(posedge DCLK)begin 
   if(RST) begin //PWM_CLK pin
    adc_wr_addr <= 13'h1fff;
    adc_wr_en   <= 0;
   end else if(adc_trig) begin
    adc_wr_addr <= 0;
    adc_wr_en   <= 1;
   end else if(adc_wr_addr!=13'h1fff) begin
    adc_wr_addr <= adc_wr_addr + 1;
   end else if(adc_wr_addr==13'h1fff) begin
    adc_wr_en   <= 0;
   end
  end
  
  //SRAM for ADC DATA Writing and Reading
  assign adc_wr_data = {TOP_T2,TOP_T1,HV_EN,HILO,ADC_DATA,2'd0};
  wire [13:0] ADDRESS;
  assign ADDRESS = {1'b0,(adc_wr_en)?adc_wr_addr:adc_rd_addr};
  SB_SPRAM256KA ram(
 		.DATAOUT(adc_rd_data),
 		.ADDRESS(ADDRESS),
 		.DATAIN(adc_wr_data),
 		.MASKWREN(4'b1111),
 		.WREN(adc_wr_en),
 		.CHIPSELECT(1'b1),
 		.CLOCK(DCLK),
 		.STANDBY(1'b0),
 		.SLEEP(1'b0),
 		.POWEROFF(1'b1)
  );
  
  //Driving output LED for status monitering
  //Red  -> Capturing Data or Busy for SPI_Read
  //Green-> READY for Capture or Read
  //Blue -> Blinks during DAC Configuration
  SB_RGBA_DRV #(
             .CURRENT_MODE ("0b0"),
             .RGB0_CURRENT ("0b111111"),
             .RGB1_CURRENT ("0b111111"),
             .RGB2_CURRENT ("0b111111")
  ) RGB_driver (
             .CURREN   (1'b1),       // I
             .RGBLEDEN (1'b1),       // I
             .RGB0PWM  (~adc_wr_en), // I
             .RGB1PWM  (adc_wr_en),  // I
             .RGB2PWM  (1'b1),  // I
             .RGB2     (RGB[2]),      // O
             .RGB1     (RGB[1]),     // O
             .RGB0     (RGB[0])        // O
  );
  assign EA_CLK = adc_wr_en; 
  assign HV_EN  = adc_wr_en;
 
endmodule
//---- Top entity
module v447f87 (
 input vc8d753,
 input va527ad,
 input v22f8d1,
 input vd2f057,
 input [7:0] v76765e,
 output v195b8b,
 output [7:0] vad664c,
 output vcdfbb7
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 assign w0 = va527ad;
 assign v195b8b = w1;
 assign w2 = vd2f057;
 assign w3 = v22f8d1;
 assign w4 = vc8d753;
 assign w5 = v76765e;
 assign vad664c = w6;
 assign vcdfbb7 = w7;
 v447f87_v69b127 v69b127 (
  .ICE_CS(w0),
  .F_MISO(w1),
  .F_MOSI(w2),
  .F_SCLK(w3),
  .RST(w4),
  .to_spi(w5),
  .from_spi(w6),
  .spi_strb(w7)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v447f87_v69b127 (
 input RST,
 input ICE_CS,
 input F_SCLK,
 input F_MOSI,
 input [7:0] to_spi,
 output F_MISO,
 output [7:0] from_spi,
 output spi_strb
);
 //SPI MODE 3: write(F_MISO)@negedge,read(F_MOSI)@posedge
 reg spi_strb;
 reg [7:0] from_spi,treg,rreg;
 reg [3:0] nb;
 assign F_MISO = (!ICE_CS) ? treg[7] : 1'bz; //1:send data,0: TRI-STATE
 always @(posedge F_SCLK or posedge RST) begin
     if (RST) begin
 		rreg	 = 8'h00;
 		from_spi = 8'h00;
 		spi_strb = 0;
 		nb		 = 0;
 	end else if (!ICE_CS) begin
 		rreg     = {rreg[6:0],F_MOSI}; //read from  F_MISO
 		nb       = nb+1;
 		if(nb!=8)
             spi_strb = 0;
 		else begin
             from_spi = rreg;
             spi_strb = 1;
             nb       = 0;
 		end
 	end //!ICE_CS
 end
 always @(negedge F_SCLK or posedge RST) begin
     if (RST) begin
 		treg     = 8'hFF;
 	end else if (!ICE_CS) begin
 		treg     = (nb==0) ? to_spi : {treg[6:0],1'b1}; //send to  F_MISO
     end //!ICE_CS
 end
 
endmodule
//---- Top entity
module v9af2a4 (
 input v009d3d,
 input v01a7fd,
 input [15:0] v2cdc1e,
 input v625d28,
 output v54a3a4,
 output ve4659c,
 output v390ac4
);
 wire w0;
 wire w1;
 wire [0:15] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign w0 = v009d3d;
 assign w1 = v01a7fd;
 assign w2 = v2cdc1e;
 assign w3 = v625d28;
 assign v54a3a4 = w4;
 assign ve4659c = w5;
 assign v390ac4 = w6;
 v9af2a4_v3f5e74 v3f5e74 (
  .DCLK(w0),
  .rst(w1),
  .dac_data(w2),
  .dac_valid(w3),
  .DAC_CS(w4),
  .DAC_SCLK(w5),
  .DAC_MOSI(w6)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v9af2a4_v3f5e74 (
 input DCLK,
 input rst,
 input [15:0] dac_data,
 input dac_valid,
 output DAC_CS,
 output DAC_SCLK,
 output DAC_MOSI
);
 localparam max_div_cnt = 10;
 reg data_valid_z, work, sck_int;
 reg [3:0] state;   reg [7:0]  clk_div_cnt;
 reg [4:0] bit_cnt; reg [15:0] shift_reg;
 assign DAC_SCLK       = sck_int && !DAC_CS;
 assign DAC_CS         = (bit_cnt < 16) ? ~work : 1;
 assign DAC_MOSI       = shift_reg[15];
 always @(posedge DCLK or posedge rst) begin
 	if (rst == 1) begin
 		work<=0; data_valid_z<=0; clk_div_cnt<=0; bit_cnt<=0; sck_int<=0;
 	end else begin
 		data_valid_z <= dac_valid;
 		if (work == 0)
 			sck_int <= 0;
 		else if (clk_div_cnt == max_div_cnt) //clk_div_cnt_ov
 			sck_int <= ~sck_int;
 		if ((bit_cnt == 19) && (clk_div_cnt == max_div_cnt)) //end_work
 			work <= 0;
 		else if (dac_valid == 1 && data_valid_z == 0)
 			work <= 1;
 		if (dac_valid == 1 && data_valid_z == 0) begin
 			shift_reg <= dac_data;
 			bit_cnt <= 0;
 		end else if ((clk_div_cnt == max_div_cnt) && sck_int == 1) begin
 			shift_reg <= {shift_reg[14:0], 1'b0};
 			bit_cnt <= bit_cnt + 1;
 		end
 		if((clk_div_cnt == max_div_cnt) || work == 0) clk_div_cnt <=  0;
 		else clk_div_cnt <= clk_div_cnt + 1;
 	end
 end
 
endmodule
//---- Top entity
module v014e82 (
 input v92a92f,
 input [12:0] v5a60f2,
 output v1955dc,
 output v05493a,
 output v24805d
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:12] w4;
 assign w0 = v92a92f;
 assign v24805d = w1;
 assign v1955dc = w2;
 assign v05493a = w3;
 assign w4 = v5a60f2;
 v014e82_vf8ce5e vf8ce5e (
  .DCLK(w0),
  .Pdamp(w1),
  .PHV(w2),
  .PnHV(w3),
  .adc_wr_addr(w4)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v014e82_vf8ce5e (
 input DCLK,
 input [12:0] adc_wr_addr,
 output PHV,
 output PnHV,
 output Pdamp
);
 reg PHV,PnHV,Pdamp;
  //Pulsar signals generation
  //@64MHz 8 clocks = 125ns; 32 clocks = 500ns; 64 clocks = 1000ns;
  //@48MHz 6 clocks = 125ns; 24 clocks = 500ns; 48 clocks = 1000ns;
  always@(posedge DCLK)begin
 //  PHV   <= (adc_wr_addr>=32 && adc_wr_addr<40 ) ? 1'b1 : 1'b0;
 //  PnHV  <= (adc_wr_addr>=48 && adc_wr_addr<56 ) ? 1'b1 : 1'b0;
 //  Pdamp <= (adc_wr_addr>=64 && adc_wr_addr<128) ? 1'b1 : 1'b0;
   PHV   <= (adc_wr_addr>=24 && adc_wr_addr<30 ) ? 1'b1 : 1'b0;
   PnHV  <= (adc_wr_addr>=36 && adc_wr_addr<42 ) ? 1'b1 : 1'b0;
   Pdamp <= (adc_wr_addr>=48 && adc_wr_addr<96 ) ? 1'b1 : 1'b0;
  end
  
endmodule
//---- Top entity
module vfa63e7 (
 input v92a92f,
 input vc8d753,
 input [7:0] vcd2f9e,
 input va44b93,
 input [15:0] v77f475,
 output [15:0] v679ba5,
 output vb208b1,
 output vd5908e,
 output [12:0] v4ca04a,
 output vd13f63,
 output [7:0] vb674e4
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire [0:15] w7;
 wire w8;
 wire [0:12] w9;
 wire [0:15] w10;
 assign w0 = vc8d753;
 assign w1 = v92a92f;
 assign vd13f63 = w2;
 assign w3 = vcd2f9e;
 assign w4 = va44b93;
 assign vb674e4 = w5;
 assign vd5908e = w6;
 assign v679ba5 = w7;
 assign vb208b1 = w8;
 assign v4ca04a = w9;
 assign w10 = v77f475;
 vfa63e7_vf8ce5e vf8ce5e (
  .RST(w0),
  .DCLK(w1),
  .HILO(w2),
  .from_spi(w3),
  .spi_strb(w4),
  .to_spi(w5),
  .adc_trig(w6),
  .dac_data(w7),
  .dac_valid(w8),
  .adc_rd_addr(w9),
  .adc_rd_data(w10)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module vfa63e7_vf8ce5e (
 input DCLK,
 input RST,
 input [7:0] from_spi,
 input spi_strb,
 input [15:0] adc_rd_data,
 output [15:0] dac_data,
 output dac_valid,
 output adc_trig,
 output [12:0] adc_rd_addr,
 output HILO,
 output [7:0] to_spi
);
  reg         adc_trig;
  reg  [15:0] dac_data;
  reg         dac_valid;
  reg         HILO;
  reg  [12:0] adc_rd_addr;
  reg  [15:0] spi_data;
  reg  [13:0] spi_data_active;
  reg         spi_strb_adc_clk;
  reg         spi_strb_adc_clk_z;
  reg         spi_strb_adc_clk_zz;
  reg         spi_strb_adc_clk_zzz;
  reg         spi_strb_adc_clk_zzzz;
  reg         spi_data_byte;
  reg  [1:0]  spi_mode;
  assign to_spi = (spi_data_byte == 0) ? adc_rd_data[7:0] : adc_rd_data[15:8];
  always @(posedge DCLK or posedge RST) begin //Clock domain crossing Logic
 	if (RST) begin
 		spi_data <= 0;
 		spi_strb_adc_clk <= 0;
 		spi_strb_adc_clk_z <= 0;
 		spi_strb_adc_clk_zz <= 0;
 		spi_strb_adc_clk_zzz <= 0;
 		spi_strb_adc_clk_zzzz <= 0;
 		spi_data_byte <= 0;
 	end else begin
 		spi_strb_adc_clk_zzzz <= spi_strb_adc_clk_zzz;
 		spi_strb_adc_clk_zzz <= spi_strb_adc_clk_zz;
 		spi_strb_adc_clk_zz <= spi_strb_adc_clk_z;
 		spi_strb_adc_clk_z <= spi_strb_adc_clk;
 		spi_strb_adc_clk <= spi_strb;
 		if (spi_strb_adc_clk_zzzz == 0 && spi_strb_adc_clk_zzz == 1 && spi_data_byte == 0) begin
 			{spi_mode,spi_data_active} <= spi_data;
 		end else spi_mode <= 0;
 		if (spi_strb_adc_clk_zzz == 0 && spi_strb_adc_clk_zz == 1) begin
 			spi_data <= {spi_data[7:0], from_spi};
 			spi_data_byte <= ~spi_data_byte;
 		end
 	end
  end
  always@(posedge DCLK)begin
    if(RST)begin
     adc_trig       <= 0;
     HILO           <= 0;
     dac_data       <= 0;
     dac_valid      <= 0;
 	adc_rd_addr    <= 0;
    end else begin
     adc_trig       <= (spi_mode==2'b01);
     HILO           <= (spi_mode==2'b01) ? spi_data_active[0] : HILO;
     dac_data[7:0]  <= (spi_mode==2'b10)?spi_data_active[7:0]:dac_data[7:0];
     dac_data[15:8] <= (spi_mode==2'b11)?spi_data_active[7:0]:dac_data[15:8];
     dac_valid      <= (spi_mode==2'b11);
 	adc_rd_addr    <= spi_data_active[12:0];
    end
  end
  
endmodule
