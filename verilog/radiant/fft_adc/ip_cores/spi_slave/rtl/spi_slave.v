
/*******************************************************************************
    Verilog netlist generated by IPGEN Radiant Software (64-bit) 2.0.0.64.1
    Soft IP Version: 1.0.0
    Thu Jan 09 20:00:39 2020
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
module spi_slave (spi1_miso_io, 
        spi1_mosi_io, 
        spi1_sck_io, 
        spi1_scs_n_i, 
        spi1_mcs_n_o, 
        rst_i, 
        ipload_i, 
        ipdone_o, 
        sb_clk_i, 
        sb_wr_i, 
        sb_stb_i, 
        sb_adr_i, 
        sb_dat_i, 
        sb_dat_o, 
        sb_ack_o, 
        spi_pirq_o, 
        spi_pwkup_o) ;
    inout spi1_miso_io ; 
    inout spi1_mosi_io ; 
    inout spi1_sck_io ; 
    input spi1_scs_n_i ; 
    output [3:0] spi1_mcs_n_o ; 
    input rst_i ; 
    input ipload_i ; 
    output ipdone_o ; 
    input sb_clk_i ; 
    input sb_wr_i ; 
    input sb_stb_i ; 
    input [7:0] sb_adr_i ; 
    input [7:0] sb_dat_i ; 
    output [7:0] sb_dat_o ; 
    output sb_ack_o ; 
    output [1:0] spi_pirq_o ; 
    output [1:0] spi_pwkup_o ; 
    spi_slave_ipgen_lscc_spi_i2c #(.i2c_left_enable(0),
            .i2c_right_enable(0),
            .spi_left_enable(0),
            .spi_right_enable(1),
            .FREQUENCY_PIN_SBCLKI("48.0"),
            .I2C_LEFT_CLK_PRESCALE("119"),
            .I2C_LEFT_CLK_DIVIDER(480),
            .I2C_LEFT_SLAVE_INIT_ADDR("0b1111101"),
            .I2C_LEFT_SDA_INPUT_DELAYED("1"),
            .I2C_LEFT_SDA_OUTPUT_DELAYED("0"),
            .I2C_LEFT_INIT_VALUE_0(128),
            .I2C_LEFT_INIT_VALUE_1(31),
            .I2C_LEFT_INIT_VALUE_2(0),
            .I2C_RIGHT_CLK_PRESCALE("119"),
            .I2C_RIGHT_CLK_DIVIDER(480),
            .I2C_RIGHT_SLAVE_INIT_ADDR("0b1111110"),
            .I2C_RIGHT_SDA_INPUT_DELAYED("1"),
            .I2C_RIGHT_SDA_OUTPUT_DELAYED("0"),
            .I2C_RIGHT_INIT_VALUE_5(128),
            .I2C_RIGHT_INIT_VALUE_6(31),
            .I2C_RIGHT_INIT_VALUE_7(0),
            .SPI_LEFT_CLK_DIVIDER(1),
            .SPI_LEFT_CLK_PRESCALE("0"),
            .SPI_LEFT_MASTER_CHIP_SELECTS(1),
            .SPI_LEFT_WAKEUP_ENABLE(1),
            .SPI_LEFT_INIT_VALUE_10(8),
            .SPI_LEFT_INIT_VALUE_13(0),
            .SPI_RIGHT_CLK_DIVIDER(1),
            .SPI_RIGHT_CLK_PRESCALE("0"),
            .SPI_RIGHT_MASTER_CHIP_SELECTS(1),
            .SPI_RIGHT_WAKEUP_ENABLE(1),
            .SPI_RIGHT_INIT_VALUE_15(0),
            .SPI_RIGHT_INIT_VALUE_18(0)) lscc_spi_i2c_inst (.i2c2_scl_io(), 
                .i2c2_sda_io(), 
                .i2c1_scl_io(), 
                .i2c1_sda_io(), 
                .spi2_miso_io(), 
                .spi2_mosi_io(), 
                .spi2_sck_io(), 
                .spi2_scs_n_i(1'b0), 
                .spi2_mcs_n_o(), 
                .spi1_miso_io(spi1_miso_io), 
                .spi1_mosi_io(spi1_mosi_io), 
                .spi1_sck_io(spi1_sck_io), 
                .spi1_scs_n_i(spi1_scs_n_i), 
                .spi1_mcs_n_o(spi1_mcs_n_o[3:0]), 
                .rst_i(rst_i), 
                .ipload_i(ipload_i), 
                .ipdone_o(ipdone_o), 
                .sb_clk_i(sb_clk_i), 
                .sb_wr_i(sb_wr_i), 
                .sb_stb_i(sb_stb_i), 
                .sb_adr_i(sb_adr_i[7:0]), 
                .sb_dat_i(sb_dat_i[7:0]), 
                .sb_dat_o(sb_dat_o[7:0]), 
                .sb_ack_o(sb_ack_o), 
                .i2c_pirq_o(), 
                .i2c_pwkup_o(), 
                .spi_pirq_o(spi_pirq_o[1:0]), 
                .spi_pwkup_o(spi_pwkup_o[1:0])) ; 
endmodule



`timescale 1ns/1ns
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2017 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_spi_i2c.v
// Title                 :
// Dependencies          : I2C_B primitive
//                       : SPI_B primitive
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             :
// Changes Made          : Initial release.
// =============================================================================
module spi_slave_ipgen_lscc_spi_i2c #(parameter num_regs = 23, 
        parameter i2c_left_enable = 0, 
        parameter i2c_right_enable = 0, 
        parameter spi_left_enable = 0, 
        parameter spi_right_enable = 0, 
        parameter FREQUENCY_PIN_SBCLKI = "NONE", 
        parameter I2C_LEFT_CLK_DIVIDER = 8, 
        parameter I2C_LEFT_CLK_PRESCALE = "1", 
        parameter I2C_LEFT_INIT_VALUE_0 = 0, 
        parameter I2C_LEFT_INIT_VALUE_1 = 0, 
        parameter I2C_LEFT_INIT_VALUE_2 = 0, 
        parameter I2C_LEFT_SLAVE_INIT_ADDR = "0b1111100001", 
        parameter I2C_LEFT_SDA_INPUT_DELAYED = "1", 
        parameter I2C_LEFT_SDA_OUTPUT_DELAYED = "0", 
        parameter I2C_RIGHT_CLK_DIVIDER = 8, 
        parameter I2C_RIGHT_CLK_PRESCALE = "1", 
        parameter I2C_RIGHT_INIT_VALUE_5 = 0, 
        parameter I2C_RIGHT_INIT_VALUE_6 = 0, 
        parameter I2C_RIGHT_INIT_VALUE_7 = 0, 
        parameter I2C_RIGHT_SLAVE_INIT_ADDR = "0b1111100010", 
        parameter I2C_RIGHT_SDA_INPUT_DELAYED = "1", 
        parameter I2C_RIGHT_SDA_OUTPUT_DELAYED = "0", 
        parameter SPI_LEFT_INIT_VALUE_10 = 0, 
        parameter SPI_LEFT_INIT_VALUE_13 = 0, 
        parameter SPI_RIGHT_INIT_VALUE_15 = 0, 
        parameter SPI_RIGHT_INIT_VALUE_18 = 0, 
        parameter SPI_LEFT_WAKEUP_ENABLE = 1, 
        parameter SPI_LEFT_CLK_DIVIDER = 2, 
        parameter SPI_LEFT_CLK_PRESCALE = "1", 
        parameter SPI_LEFT_MASTER_CHIP_SELECTS = 1, 
        parameter SPI_RIGHT_WAKEUP_ENABLE = 1, 
        parameter SPI_RIGHT_CLK_DIVIDER = 2, 
        parameter SPI_RIGHT_CLK_PRESCALE = "1", 
        parameter SPI_RIGHT_MASTER_CHIP_SELECTS = 1) (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // (I2C_LEFT_CLK_PRESCALE+1) * 4
    // (1 - 1023)
    // (I2C_RIGHT_CLK_PRESCALE+1) * 4
    // (1 - 1023)
    // SPI_LEFT_CLK_PRESCALE + 1
    // (1 - 63)
    // SPI_RIGHT_CLK_PRESCALE + 1
    // (1 - 63)
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    // I2C Left
    inout wire i2c2_scl_io, 
    inout wire i2c2_sda_io, 
    // I2c Right
    inout wire i2c1_scl_io, 
    inout wire i2c1_sda_io, 
    // SPI Left
    inout wire spi2_miso_io, 
    inout wire spi2_mosi_io, 
    inout wire spi2_sck_io, 
    input wire spi2_scs_n_i, 
    output wire [3:0] spi2_mcs_n_o, 
    // SPI Right
    inout wire spi1_miso_io, 
    inout wire spi1_mosi_io, 
    inout wire spi1_sck_io, 
    input wire spi1_scs_n_i, 
    output wire [3:0] spi1_mcs_n_o, 
    // Fabric Interface
    input wire rst_i, 
    input wire ipload_i, 
    output wire ipdone_o, 
    input wire sb_clk_i, 
    input wire sb_wr_i, 
    input wire sb_stb_i, 
    input wire [7:0] sb_adr_i, 
    input wire [7:0] sb_dat_i, 
    output wire [7:0] sb_dat_o, 
    output wire sb_ack_o, 
    output wire [1:0] i2c_pirq_o, 
    output wire [1:0] i2c_pwkup_o, 
    output wire [1:0] spi_pirq_o, 
    output wire [1:0] spi_pwkup_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam RSVD = 8'hFF ; 
    // I2C Base Address
    localparam I2CBADDRL = 4'b0001 ; // I2C LEFT
    localparam I2CBADDRR = 4'b0011 ; // I2C RIGHT
    // I2C Register Address
    localparam I2CCR1 = 4'b1000 ; // I2C Control Register 1
    localparam I2CCMDR = 4'b1001 ; // I2C Command Register
    localparam I2CBRLSB = 4'b1010 ; // I2C Clock Presale register, LSB
    localparam I2CBRMSB = 4'b1011 ; // I2C Clock Presale register, MSB
    localparam I2CSR = 4'b1100 ; // I2C Status Register
    localparam I2CTXDR = 4'b1101 ; // I2C Transmitting Data Register
    localparam I2CRXDR = 4'b1110 ; // I2C Receiving Data Register
    localparam I2CGCDR = 4'b1111 ; // I2C General Call Information Register
    localparam I2CINTCR = 4'b0111 ; // I2C Interrupt Control Register
    localparam I2CINTSR = 4'b0110 ; // I2C Interrupt Status Register
    localparam I2CSADDR = 4'b0011 ; // I2C Slave address MSB
    // SPI Base Address
    localparam SPIBADDRL = 4'b0000 ; // SPI LEFT
    localparam SPIBADDRR = 4'b0010 ; // SPI RIGHT
    // SPI Register Address
    localparam SPICR0 = 4'b1000 ; // SPI Control Register0
    localparam SPICR1 = 4'b1001 ; // SPI Control Register1
    localparam SPICR2 = 4'b1010 ; // SPI Control Register2
    localparam SPIBR = 4'b1011 ; // SPI Baud Rate Register
    localparam SPISR = 4'b1100 ; // SPI Status Register
    localparam SPITXDR = 4'b1101 ; // SPI Transmitting Data Register
    localparam SPIRXDR = 4'b1110 ; // SPI Receiving Data Register
    localparam SPICSR = 4'b1111 ; // SPI Chip Select Mask for Master Mode
    localparam SPIINTCR = 4'b0111 ; // SPI Interrupt Control Register
    localparam SPIINTSR = 4'b0110 ; // SPI Interrupt Status Register
    // -----------------------------------------------------------------------------
    // Combinatorial/Sequential Registers
    // -----------------------------------------------------------------------------
    reg [7:0] SBDATo_i ; 
    reg load_d1 ; 
    reg load_d2 ; 
    reg start ; 
    reg pup ; 
    reg run ; 
    reg [5:0] trans_count ; 
    reg IPDONE_i ; 
    reg sb_idle ; 
    reg strobe ; 
    reg wb_we_ix ; 
    reg wb_stb_ix ; 
    reg [7:0] wb_adr_ix ; 
    reg [7:0] wb_dat_ix ; 
    reg [5:0] start_count ; 
    reg [5:0] next_count ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire hard_SBWRi ; 
    wire hard_SBSTBi ; 
    wire [7:0] hard_SBADRi ; 
    wire [7:0] hard_SBDATi ; 
    wire hard00_SBACKO ; 
    wire hard01_SBACKO ; 
    wire hard10_SBACKO ; 
    wire hard11_SBACKO ; 
    wire [3:0] hard_ACKs ; 
    wire SBACKo_i ; 
    wire [7:0] hard00_SBDATo ; 
    wire [7:0] hard01_SBDATo ; 
    wire [7:0] hard10_SBDATo ; 
    wire [7:0] hard11_SBDATo ; 
    wire ssm_SBWRi ; 
    wire ssm_SBSTBi ; 
    wire [7:0] ssm_SBADRi ; 
    wire [7:0] ssm_SBDATi ; 
    wire I2C2_SCLo ; 
    wire I2C2_SCLoe ; 
    wire I2C2_SCLi ; 
    wire I2C2_SDAo ; 
    wire I2C2_SDAoe ; 
    wire I2C2_SDAi ; 
    wire I2C1_SCLo ; 
    wire I2C1_SCLoe ; 
    wire I2C1_SCLi ; 
    wire I2C1_SDAo ; 
    wire I2C1_SDAoe ; 
    wire I2C1_SDAi ; 
    wire SPI2_SO ; 
    wire SPI2_SOoe ; 
    wire SPI2_MI ; 
    wire SPI2_MO ; 
    wire SPI2_MOoe ; 
    wire SPI2_SI ; 
    wire SPI2_SCKo ; 
    wire SPI2_SCKoe ; 
    wire SPI2_SCKi ; 
    wire SPI2_SCSNi ; 
    wire [3:0] SPI2_MCSNo ; 
    wire [3:0] SPI2_MCSNoe ; 
    wire SPI1_SO ; 
    wire SPI1_SOoe ; 
    wire SPI1_MI ; 
    wire SPI1_MO ; 
    wire SPI1_MOoe ; 
    wire SPI1_SI ; 
    wire SPI1_SCKo ; 
    wire SPI1_SCKoe ; 
    wire SPI1_SCKi ; 
    wire SPI1_SCSNi ; 
    wire [3:0] SPI1_MCSNo ; 
    wire [3:0] SPI1_MCSNoe ; 
    wire [7:0] init_value [0:(num_regs - 1)] ; 
    wire [7:0] init_addr [0:(num_regs - 1)] ; 
    wire [11:0] i2c_left_prescale ; 
    wire [11:0] i2c_right_prescale ; 
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign i2c_left_prescale = ((I2C_LEFT_CLK_DIVIDER > 4) ? (I2C_LEFT_CLK_DIVIDER - 4) : 0) ; 
    assign i2c_right_prescale = ((I2C_RIGHT_CLK_DIVIDER > 4) ? (I2C_RIGHT_CLK_DIVIDER - 4) : 0) ; 
    assign init_value[0] = I2C_LEFT_INIT_VALUE_0 ; 
    assign init_value[1] = I2C_LEFT_INIT_VALUE_1 ; 
    assign init_value[2] = I2C_LEFT_INIT_VALUE_2 ; 
    assign init_value[3] = i2c_left_prescale[9:2] ; 
    assign init_value[4] = {6'd0,
                i2c_left_prescale[11:10]} ; 
    assign init_value[5] = I2C_RIGHT_INIT_VALUE_5 ; 
    assign init_value[6] = I2C_RIGHT_INIT_VALUE_6 ; 
    assign init_value[7] = I2C_RIGHT_INIT_VALUE_7 ; 
    assign init_value[8] = i2c_right_prescale[9:2] ; 
    assign init_value[9] = {6'd0,
                i2c_right_prescale[11:10]} ; 
    assign init_value[10] = {3'd0,
                SPI_LEFT_INIT_VALUE_10[3:0],
                1'b0} ; 
    assign init_value[11] = {4'd0,
                SPI_LEFT_MASTER_CHIP_SELECTS[3:0]} ; 
    assign init_value[12] = {1'b1,
                SPI_LEFT_WAKEUP_ENABLE[0],
                6'd0} ; 
    assign init_value[13] = (SPI_LEFT_INIT_VALUE_13 & 8'hA7) ; // 8'hA7 - masks reserved bits
    assign init_value[14] = (SPI_LEFT_CLK_DIVIDER - 1) ; 
    assign init_value[15] = {3'd0,
                SPI_RIGHT_INIT_VALUE_15[3:0],
                1'b0} ; 
    assign init_value[16] = {4'd0,
                SPI_RIGHT_MASTER_CHIP_SELECTS[3:0]} ; 
    assign init_value[17] = {1'b1,
                SPI_RIGHT_WAKEUP_ENABLE[0],
                6'd0} ; 
    assign init_value[18] = (SPI_RIGHT_INIT_VALUE_18 & 8'hA7) ; // 8'hA7 - masks reserved bits
    assign init_value[19] = (SPI_RIGHT_CLK_DIVIDER - 1) ; 
    assign init_value[20] = RSVD ; 
    assign init_value[21] = RSVD ; 
    assign init_value[22] = RSVD ; 
    assign init_addr[20] = RSVD ; 
    assign init_addr[21] = RSVD ; 
    assign init_addr[22] = RSVD ; 
    // SYSTEM BUS multiplexing
    assign hard_SBWRi = (IPDONE_i ? sb_wr_i : ssm_SBWRi) ; 
    assign hard_SBSTBi = (IPDONE_i ? sb_stb_i : ssm_SBSTBi) ; 
    assign hard_SBADRi = (IPDONE_i ? sb_adr_i : ssm_SBADRi) ; 
    assign hard_SBDATi = (IPDONE_i ? sb_dat_i : ssm_SBDATi) ; 
    // {i2c_right, spi_righ, i2c_left, spi_left}
    assign hard_ACKs = {hard11_SBACKO,
                hard10_SBACKO,
                hard01_SBACKO,
                hard00_SBACKO} ; 
    assign SBACKo_i = (|hard_ACKs) ; 
    // Initialization SSM outputs
    assign ssm_SBWRi = 1 ; // All transaction are WRITE
    assign ssm_SBSTBi = strobe ; 
    assign ssm_SBADRi = init_addr[trans_count] ; 
    assign ssm_SBDATi = init_value[trans_count] ; 
    assign sb_dat_o = SBDATo_i ; 
    assign sb_ack_o = (SBACKo_i && IPDONE_i) ; 
    assign ipdone_o = IPDONE_i ; 
    // -----------------------------------------------------------------------------
    // Generate Assign Statements
    // -----------------------------------------------------------------------------
    generate
        if ((i2c_left_enable == 1)) 
            begin : genblk1
                assign init_addr[0] = {I2CBADDRL,
                            I2CCR1} ; 
                assign init_addr[1] = {I2CBADDRL,
                            I2CSADDR} ; 
                assign init_addr[2] = {I2CBADDRL,
                            I2CINTCR} ; 
                assign init_addr[3] = {I2CBADDRL,
                            I2CBRLSB} ; 
                assign init_addr[4] = {I2CBADDRL,
                            I2CBRMSB} ; 
            end
        else
            begin : genblk1
                assign init_addr[0] = RSVD ; 
                assign init_addr[1] = RSVD ; 
                assign init_addr[2] = RSVD ; 
                assign init_addr[3] = RSVD ; 
                assign init_addr[4] = RSVD ; 
            end
        if ((i2c_right_enable == 1)) 
            begin : genblk2
                assign init_addr[5] = {I2CBADDRR,
                            I2CCR1} ; 
                assign init_addr[6] = {I2CBADDRR,
                            I2CSADDR} ; 
                assign init_addr[7] = {I2CBADDRR,
                            I2CINTCR} ; 
                assign init_addr[8] = {I2CBADDRR,
                            I2CBRLSB} ; 
                assign init_addr[9] = {I2CBADDRR,
                            I2CBRMSB} ; 
            end
        else
            begin : genblk2
                assign init_addr[5] = RSVD ; 
                assign init_addr[6] = RSVD ; 
                assign init_addr[7] = RSVD ; 
                assign init_addr[8] = RSVD ; 
                assign init_addr[9] = RSVD ; 
            end
        if ((spi_left_enable == 1)) 
            begin : genblk3
                assign init_addr[10] = {SPIBADDRL,
                            SPIINTCR} ; 
                assign init_addr[11] = {SPIBADDRL,
                            SPICSR} ; 
                assign init_addr[12] = {SPIBADDRL,
                            SPICR1} ; 
                assign init_addr[13] = {SPIBADDRL,
                            SPICR2} ; 
                assign init_addr[14] = {SPIBADDRL,
                            SPIBR} ; 
            end
        else
            begin : genblk3
                assign init_addr[10] = RSVD ; 
                assign init_addr[11] = RSVD ; 
                assign init_addr[12] = RSVD ; 
                assign init_addr[13] = RSVD ; 
                assign init_addr[14] = RSVD ; 
            end
        if ((spi_right_enable == 1)) 
            begin : genblk4
                assign init_addr[15] = {SPIBADDRR,
                            SPIINTCR} ; 
                assign init_addr[16] = {SPIBADDRR,
                            SPICSR} ; 
                assign init_addr[17] = {SPIBADDRR,
                            SPICR1} ; 
                assign init_addr[18] = {SPIBADDRR,
                            SPICR2} ; 
                assign init_addr[19] = {SPIBADDRR,
                            SPIBR} ; 
            end
        else
            begin : genblk4
                assign init_addr[15] = RSVD ; 
                assign init_addr[16] = RSVD ; 
                assign init_addr[17] = RSVD ; 
                assign init_addr[18] = RSVD ; 
                assign init_addr[19] = RSVD ; 
            end
    endgenerate
    generate
        if ((i2c_left_enable == 1)) 
            begin : genblk5
                assign i2c2_scl_io = (I2C2_SCLoe ? I2C2_SCLo : 1'bZ) ; 
                assign i2c2_sda_io = (I2C2_SDAoe ? I2C2_SDAo : 1'bZ) ; 
                assign I2C2_SCLi = i2c2_scl_io ; 
                assign I2C2_SDAi = i2c2_sda_io ; 
            end
        if ((i2c_right_enable == 1)) 
            begin : genblk6
                assign i2c1_scl_io = (I2C1_SCLoe ? I2C1_SCLo : 1'bZ) ; 
                assign i2c1_sda_io = (I2C1_SDAoe ? I2C1_SDAo : 1'bZ) ; 
                assign I2C1_SCLi = i2c1_scl_io ; 
                assign I2C1_SDAi = i2c1_sda_io ; 
            end
        if ((spi_left_enable == 1)) 
            begin : genblk7
                assign spi2_miso_io = (SPI2_SOoe ? SPI2_SO : 1'bZ) ; 
                assign SPI2_MI = spi2_miso_io ; 
                assign spi2_mosi_io = (SPI2_MOoe ? SPI2_MO : 1'bZ) ; 
                assign SPI2_SI = spi2_mosi_io ; 
                assign spi2_sck_io = (SPI2_SCKoe ? SPI2_SCKo : 1'bZ) ; 
                assign SPI2_SCKi = spi2_sck_io ; 
                assign SPI2_SCSNi = spi2_scs_n_i ; 
                assign spi2_mcs_n_o[3] = (SPI2_MCSNoe[3] ? SPI2_MCSNo[3] : 1'bZ) ; 
                assign spi2_mcs_n_o[2] = (SPI2_MCSNoe[2] ? SPI2_MCSNo[2] : 1'bZ) ; 
                assign spi2_mcs_n_o[1] = (SPI2_MCSNoe[1] ? SPI2_MCSNo[1] : 1'bZ) ; 
                assign spi2_mcs_n_o[0] = (SPI2_MCSNoe[0] ? SPI2_MCSNo[0] : 1'bZ) ; 
            end
        if ((spi_right_enable == 1)) 
            begin : genblk8
                assign spi1_miso_io = (SPI1_SOoe ? SPI1_SO : 1'bZ) ; 
                assign SPI1_MI = spi1_miso_io ; 
                assign spi1_mosi_io = (SPI1_MOoe ? SPI1_MO : 1'bZ) ; 
                assign SPI1_SI = spi1_mosi_io ; 
                assign spi1_sck_io = (SPI1_SCKoe ? SPI1_SCKo : 1'bZ) ; 
                assign SPI1_SCKi = spi1_sck_io ; 
                assign SPI1_SCSNi = spi1_scs_n_i ; 
                assign spi1_mcs_n_o[3] = (SPI1_MCSNoe[3] ? SPI1_MCSNo[3] : 1'bZ) ; 
                assign spi1_mcs_n_o[2] = (SPI1_MCSNoe[2] ? SPI1_MCSNo[2] : 1'bZ) ; 
                assign spi1_mcs_n_o[1] = (SPI1_MCSNoe[1] ? SPI1_MCSNo[1] : 1'bZ) ; 
                assign spi1_mcs_n_o[0] = (SPI1_MCSNoe[0] ? SPI1_MCSNo[0] : 1'bZ) ; 
            end
    endgenerate
    // -----------------------------------------------------------------------------
    // Combinatorial Blocks
    // -----------------------------------------------------------------------------
    always
        @(*)
        begin
            wb_we_ix = hard_SBWRi ;
        end
    always
        @(*)
        begin
            wb_stb_ix = hard_SBSTBi ;
        end
    always
        @(*)
        begin
            wb_adr_ix = hard_SBADRi ;
        end
    always
        @(*)
        begin
            wb_dat_ix = hard_SBDATi ;
        end
    //-----------------------------------------------------------------------------
    // DATo mux
    //-----------------------------------------------------------------------------
    always
        @(*)
        begin
            case (hard_ACKs)
            4'b1000 : 
                SBDATo_i = hard11_SBDATo ;
            4'b0100 : 
                SBDATo_i = hard10_SBDATo ;
            4'b0010 : 
                SBDATo_i = hard01_SBDATo ;
            4'b0001 : 
                SBDATo_i = hard00_SBDATo ;
            default : 
                SBDATo_i = 8'b0 ;
            endcase 
        end
    //-----------------------------------------------------------------------------
    //   Initialization SSM control: Start, Run, Done
    //-----------------------------------------------------------------------------
    always
        @(posedge sb_clk_i or 
            posedge rst_i)
        begin
            if (rst_i) 
                begin
                    load_d1 <=  0 ;
                    load_d2 <=  0 ;
                    start <=  0 ;
                    pup <=  1 ;
                    run <=  0 ;
                    trans_count <=  0 ;
                    IPDONE_i <=  0 ;
                end
            else
                begin
                    load_d1 <=  (ipload_i || pup) ;
                    load_d2 <=  load_d1 ;
                    start <=  (load_d1 && (!load_d2)) ;// rising-edge detection
                    if (start) // clear power-up launch flag
                        pup <=  0 ;
                    if (start) 
                        run <=  1 ;
                    else
                        // start init sequence
                        if (IPDONE_i) //  clear when init complete
                            run <=  0 ;
                    // reset control upon Start
                    if (start) 
                        begin
                            trans_count <=  start_count ;
                            IPDONE_i <=  0 ;
                        end
                    else
                        // DONE
                        if ((init_addr[trans_count] == 8'hFF)) 
                            begin
                                IPDONE_i <=  1 ;
                            end
                        else
                            // increment if not DONE
                            if (SBACKo_i) 
                                begin
                                    trans_count <=  next_count ;
                                end
                end
        end
    always//--always @*--
        @(*)
        begin
            start_count = (i2c_left_enable ? 6'd0 : (i2c_right_enable ? 6'd5 : (spi_left_enable ? 6'd10 : (spi_right_enable ? 6'd15 : 6'd20)))) ;
            next_count = ((((trans_count + 1) < 6'd20) && (init_addr[(trans_count + 1)] != 8'hFF)) ? (trans_count + 1) : ((((trans_count + 6) < 6'd20) && (init_addr[(trans_count + 6)] != 8'hFF)) ? (trans_count + 6) : ((((trans_count + 11) < 6'd20) && (init_addr[(trans_count + 11)] != 8'hFF)) ? (trans_count + 11) : 6'd20))) ;
        end
    //-----------------------------------------------------------------------------
    // System Bus transaction control
    // Assert stb until EFB acknowledges with sb_ack_o
    //-----------------------------------------------------------------------------
    always
        @(posedge sb_clk_i or 
            posedge rst_i)
        begin
            if (rst_i) 
                begin
                    sb_idle <=  1 ;
                    strobe <=  0 ;
                end
            else
                begin
                    //  Assert stb signals to start SB transaction
                    if (sb_idle) 
                        begin
                            if (run) 
                                begin
                                    // delay 1 ns to avoid simulation/hardware mismatch
                                    strobe <= #(1)   1 ;
                                    sb_idle <=  0 ;
                                end
                        end
                    else
                        // Monitor sb_ack_o for end of transaction
                        begin
                            if ((SBACKo_i | (!run))) 
                                begin
                                    strobe <=  0 ;
                                    sb_idle <=  1 ;
                                end
                        end
                end
        end
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        if ((i2c_left_enable == 1)) 
            begin : genblk9
                I2C_B #(.I2C_SLAVE_INIT_ADDR(I2C_LEFT_SLAVE_INIT_ADDR),
                        .BUS_ADDR74("0b0001"),
                        .I2C_CLK_DIVIDER(I2C_LEFT_CLK_PRESCALE),
                        .FREQUENCY_PIN_SBCLKI(FREQUENCY_PIN_SBCLKI),
                        .SDA_INPUT_DELAYED(I2C_LEFT_SDA_INPUT_DELAYED),
                        .SDA_OUTPUT_DELAYED(I2C_LEFT_SDA_OUTPUT_DELAYED)) u_I2C_B_INST_LT (.SBCLKI(sb_clk_i), 
                            .SBRWI(wb_we_ix), 
                            .SBSTBI(wb_stb_ix), 
                            .SBADRI7(wb_adr_ix[7]), 
                            .SBADRI6(wb_adr_ix[6]), 
                            .SBADRI5(wb_adr_ix[5]), 
                            .SBADRI4(wb_adr_ix[4]), 
                            .SBADRI3(wb_adr_ix[3]), 
                            .SBADRI2(wb_adr_ix[2]), 
                            .SBADRI1(wb_adr_ix[1]), 
                            .SBADRI0(wb_adr_ix[0]), 
                            .SBDATI7(wb_dat_ix[7]), 
                            .SBDATI6(wb_dat_ix[6]), 
                            .SBDATI5(wb_dat_ix[5]), 
                            .SBDATI4(wb_dat_ix[4]), 
                            .SBDATI3(wb_dat_ix[3]), 
                            .SBDATI2(wb_dat_ix[2]), 
                            .SBDATI1(wb_dat_ix[1]), 
                            .SBDATI0(wb_dat_ix[0]), 
                            .SCLI(I2C2_SCLi), 
                            .SDAI(I2C2_SDAi), 
                            .SBDATO7(hard01_SBDATo[7]), 
                            .SBDATO6(hard01_SBDATo[6]), 
                            .SBDATO5(hard01_SBDATo[5]), 
                            .SBDATO4(hard01_SBDATo[4]), 
                            .SBDATO3(hard01_SBDATo[3]), 
                            .SBDATO2(hard01_SBDATo[2]), 
                            .SBDATO1(hard01_SBDATo[1]), 
                            .SBDATO0(hard01_SBDATo[0]), 
                            .SBACKO(hard01_SBACKO), 
                            .I2CIRQ(i2c_pirq_o[0]), 
                            .I2CWKUP(i2c_pwkup_o[0]), 
                            .SCLO(I2C2_SCLo), 
                            .SCLOE(I2C2_SCLoe), 
                            .SDAO(I2C2_SDAo), 
                            .SDAOE(I2C2_SDAoe)) ; 
            end
        else
            begin : genblk9
                assign hard01_SBDATo[7] = 1'b0 ; 
                assign hard01_SBDATo[6] = 1'b0 ; 
                assign hard01_SBDATo[5] = 1'b0 ; 
                assign hard01_SBDATo[4] = 1'b0 ; 
                assign hard01_SBDATo[3] = 1'b0 ; 
                assign hard01_SBDATo[2] = 1'b0 ; 
                assign hard01_SBDATo[1] = 1'b0 ; 
                assign hard01_SBDATo[0] = 1'b0 ; 
                assign hard01_SBACKO = 1'b0 ; 
                assign i2c_pirq_o[0] = 1'b0 ; 
                assign i2c_pwkup_o[0] = 1'b0 ; 
            end
        if ((i2c_right_enable == 1)) 
            begin : genblk10
                I2C_B #(.I2C_SLAVE_INIT_ADDR(I2C_RIGHT_SLAVE_INIT_ADDR),
                        .BUS_ADDR74("0b0011"),
                        .I2C_CLK_DIVIDER(I2C_RIGHT_CLK_PRESCALE),
                        .FREQUENCY_PIN_SBCLKI(FREQUENCY_PIN_SBCLKI),
                        .SDA_INPUT_DELAYED(I2C_RIGHT_SDA_INPUT_DELAYED),
                        .SDA_OUTPUT_DELAYED(I2C_RIGHT_SDA_OUTPUT_DELAYED)) u_I2C_B_INST_RT (.SBCLKI(sb_clk_i), 
                            .SBRWI(wb_we_ix), 
                            .SBSTBI(wb_stb_ix), 
                            .SBADRI7(wb_adr_ix[7]), 
                            .SBADRI6(wb_adr_ix[6]), 
                            .SBADRI5(wb_adr_ix[5]), 
                            .SBADRI4(wb_adr_ix[4]), 
                            .SBADRI3(wb_adr_ix[3]), 
                            .SBADRI2(wb_adr_ix[2]), 
                            .SBADRI1(wb_adr_ix[1]), 
                            .SBADRI0(wb_adr_ix[0]), 
                            .SBDATI7(wb_dat_ix[7]), 
                            .SBDATI6(wb_dat_ix[6]), 
                            .SBDATI5(wb_dat_ix[5]), 
                            .SBDATI4(wb_dat_ix[4]), 
                            .SBDATI3(wb_dat_ix[3]), 
                            .SBDATI2(wb_dat_ix[2]), 
                            .SBDATI1(wb_dat_ix[1]), 
                            .SBDATI0(wb_dat_ix[0]), 
                            .SCLI(I2C1_SCLi), 
                            .SDAI(I2C1_SDAi), 
                            .SBDATO7(hard11_SBDATo[7]), 
                            .SBDATO6(hard11_SBDATo[6]), 
                            .SBDATO5(hard11_SBDATo[5]), 
                            .SBDATO4(hard11_SBDATo[4]), 
                            .SBDATO3(hard11_SBDATo[3]), 
                            .SBDATO2(hard11_SBDATo[2]), 
                            .SBDATO1(hard11_SBDATo[1]), 
                            .SBDATO0(hard11_SBDATo[0]), 
                            .SBACKO(hard11_SBACKO), 
                            .I2CIRQ(i2c_pirq_o[1]), 
                            .I2CWKUP(i2c_pwkup_o[1]), 
                            .SCLO(I2C1_SCLo), 
                            .SCLOE(I2C1_SCLoe), 
                            .SDAO(I2C1_SDAo), 
                            .SDAOE(I2C1_SDAoe)) ; 
            end
        else
            begin : genblk10
                assign hard11_SBDATo[7] = 1'b0 ; 
                assign hard11_SBDATo[6] = 1'b0 ; 
                assign hard11_SBDATo[5] = 1'b0 ; 
                assign hard11_SBDATo[4] = 1'b0 ; 
                assign hard11_SBDATo[3] = 1'b0 ; 
                assign hard11_SBDATo[2] = 1'b0 ; 
                assign hard11_SBDATo[1] = 1'b0 ; 
                assign hard11_SBDATo[0] = 1'b0 ; 
                assign hard11_SBACKO = 1'b0 ; 
                assign i2c_pirq_o[1] = 1'b0 ; 
                assign i2c_pwkup_o[1] = 1'b0 ; 
            end
        if ((spi_left_enable == 1)) 
            begin : genblk11
                SPI_B #(.FREQUENCY_PIN_SBCLKI(FREQUENCY_PIN_SBCLKI),
                        .SPI_CLK_DIVIDER(SPI_LEFT_CLK_PRESCALE),
                        .BUS_ADDR74("0b0000")) u_SPI_B_INST_LT (.SBCLKI(sb_clk_i), 
                            .SBRWI(wb_we_ix), 
                            .SBSTBI(wb_stb_ix), 
                            .SBADRI7(wb_adr_ix[7]), 
                            .SBADRI6(wb_adr_ix[6]), 
                            .SBADRI5(wb_adr_ix[5]), 
                            .SBADRI4(wb_adr_ix[4]), 
                            .SBADRI3(wb_adr_ix[3]), 
                            .SBADRI2(wb_adr_ix[2]), 
                            .SBADRI1(wb_adr_ix[1]), 
                            .SBADRI0(wb_adr_ix[0]), 
                            .SBDATI7(wb_dat_ix[7]), 
                            .SBDATI6(wb_dat_ix[6]), 
                            .SBDATI5(wb_dat_ix[5]), 
                            .SBDATI4(wb_dat_ix[4]), 
                            .SBDATI3(wb_dat_ix[3]), 
                            .SBDATI2(wb_dat_ix[2]), 
                            .SBDATI1(wb_dat_ix[1]), 
                            .SBDATI0(wb_dat_ix[0]), 
                            .MI(SPI2_MI), 
                            .SI(SPI2_SI), 
                            .SCKI(SPI2_SCKi), 
                            .SCSNI(SPI2_SCSNi), 
                            .SBDATO7(hard00_SBDATo[7]), 
                            .SBDATO6(hard00_SBDATo[6]), 
                            .SBDATO5(hard00_SBDATo[5]), 
                            .SBDATO4(hard00_SBDATo[4]), 
                            .SBDATO3(hard00_SBDATo[3]), 
                            .SBDATO2(hard00_SBDATo[2]), 
                            .SBDATO1(hard00_SBDATo[1]), 
                            .SBDATO0(hard00_SBDATo[0]), 
                            .SBACKO(hard00_SBACKO), 
                            .SPIIRQ(spi_pirq_o[0]), 
                            .SPIWKUP(spi_pwkup_o[0]), 
                            .SO(SPI2_SO), 
                            .SOE(SPI2_SOoe), 
                            .MO(SPI2_MO), 
                            .MOE(SPI2_MOoe), 
                            .SCKO(SPI2_SCKo), 
                            .SCKOE(SPI2_SCKoe), 
                            .MCSNO3(SPI2_MCSNo[3]), 
                            .MCSNO2(SPI2_MCSNo[2]), 
                            .MCSNO1(SPI2_MCSNo[1]), 
                            .MCSNO0(SPI2_MCSNo[0]), 
                            .MCSNOE3(SPI2_MCSNoe[3]), 
                            .MCSNOE2(SPI2_MCSNoe[2]), 
                            .MCSNOE1(SPI2_MCSNoe[1]), 
                            .MCSNOE0(SPI2_MCSNoe[0])) ; 
            end
        else
            begin : genblk11
                assign hard00_SBDATo[7] = 1'b0 ; 
                assign hard00_SBDATo[6] = 1'b0 ; 
                assign hard00_SBDATo[5] = 1'b0 ; 
                assign hard00_SBDATo[4] = 1'b0 ; 
                assign hard00_SBDATo[3] = 1'b0 ; 
                assign hard00_SBDATo[2] = 1'b0 ; 
                assign hard00_SBDATo[1] = 1'b0 ; 
                assign hard00_SBDATo[0] = 1'b0 ; 
                assign hard00_SBACKO = 1'b0 ; 
                assign spi_pirq_o[0] = 1'b0 ; 
                assign spi_pwkup_o[0] = 1'b0 ; 
            end
        if ((spi_right_enable == 1)) 
            begin : genblk12
                SPI_B #(.FREQUENCY_PIN_SBCLKI(FREQUENCY_PIN_SBCLKI),
                        .SPI_CLK_DIVIDER(SPI_RIGHT_CLK_PRESCALE),
                        .BUS_ADDR74("0b0010")) u_SPI_B_INST_RT (.SBCLKI(sb_clk_i), 
                            .SBRWI(wb_we_ix), 
                            .SBSTBI(wb_stb_ix), 
                            .SBADRI7(wb_adr_ix[7]), 
                            .SBADRI6(wb_adr_ix[6]), 
                            .SBADRI5(wb_adr_ix[5]), 
                            .SBADRI4(wb_adr_ix[4]), 
                            .SBADRI3(wb_adr_ix[3]), 
                            .SBADRI2(wb_adr_ix[2]), 
                            .SBADRI1(wb_adr_ix[1]), 
                            .SBADRI0(wb_adr_ix[0]), 
                            .SBDATI7(wb_dat_ix[7]), 
                            .SBDATI6(wb_dat_ix[6]), 
                            .SBDATI5(wb_dat_ix[5]), 
                            .SBDATI4(wb_dat_ix[4]), 
                            .SBDATI3(wb_dat_ix[3]), 
                            .SBDATI2(wb_dat_ix[2]), 
                            .SBDATI1(wb_dat_ix[1]), 
                            .SBDATI0(wb_dat_ix[0]), 
                            .MI(SPI1_MI), 
                            .SI(SPI1_SI), 
                            .SCKI(SPI1_SCKi), 
                            .SCSNI(SPI1_SCSNi), 
                            .SBDATO7(hard10_SBDATo[7]), 
                            .SBDATO6(hard10_SBDATo[6]), 
                            .SBDATO5(hard10_SBDATo[5]), 
                            .SBDATO4(hard10_SBDATo[4]), 
                            .SBDATO3(hard10_SBDATo[3]), 
                            .SBDATO2(hard10_SBDATo[2]), 
                            .SBDATO1(hard10_SBDATo[1]), 
                            .SBDATO0(hard10_SBDATo[0]), 
                            .SBACKO(hard10_SBACKO), 
                            .SPIIRQ(spi_pirq_o[1]), 
                            .SPIWKUP(spi_pwkup_o[1]), 
                            .SO(SPI1_SO), 
                            .SOE(SPI1_SOoe), 
                            .MO(SPI1_MO), 
                            .MOE(SPI1_MOoe), 
                            .SCKO(SPI1_SCKo), 
                            .SCKOE(SPI1_SCKoe), 
                            .MCSNO3(SPI1_MCSNo[3]), 
                            .MCSNO2(SPI1_MCSNo[2]), 
                            .MCSNO1(SPI1_MCSNo[1]), 
                            .MCSNO0(SPI1_MCSNo[0]), 
                            .MCSNOE3(SPI1_MCSNoe[3]), 
                            .MCSNOE2(SPI1_MCSNoe[2]), 
                            .MCSNOE1(SPI1_MCSNoe[1]), 
                            .MCSNOE0(SPI1_MCSNoe[0])) ; 
            end
        else
            begin : genblk12
                assign hard10_SBDATo[7] = 1'b0 ; 
                assign hard10_SBDATo[6] = 1'b0 ; 
                assign hard10_SBDATo[5] = 1'b0 ; 
                assign hard10_SBDATo[4] = 1'b0 ; 
                assign hard10_SBDATo[3] = 1'b0 ; 
                assign hard10_SBDATo[2] = 1'b0 ; 
                assign hard10_SBDATo[1] = 1'b0 ; 
                assign hard10_SBDATo[0] = 1'b0 ; 
                assign hard10_SBACKO = 1'b0 ; 
                assign spi_pirq_o[1] = 1'b0 ; 
                assign spi_pwkup_o[1] = 1'b0 ; 
            end
    endgenerate
endmodule


